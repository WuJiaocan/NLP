{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#!/usr/bin/env python\n",
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "from copy import deepcopy\n",
    "import re\n",
    "\n",
    "try:\n",
    "    import psyco\n",
    "    psyco.full()\n",
    "except:\n",
    "    pass\n",
    "\n",
    "try:\n",
    "    from zh_wiki import zh2Hant, zh2Hans\n",
    "except ImportError:\n",
    "    from zhtools.zh_wiki import zh2Hant, zh2Hans\n",
    "\n",
    "import sys\n",
    "py3k = sys.version_info >= (3, 0, 0)\n",
    "\n",
    "if py3k:\n",
    "    UEMPTY = ''\n",
    "else:\n",
    "    _zh2Hant, _zh2Hans = {}, {}\n",
    "    for old, new in ((zh2Hant, _zh2Hant), (zh2Hans, _zh2Hans)):\n",
    "        for k, v in old.items():\n",
    "            new[k.decode('utf8')] = v.decode('utf8')\n",
    "    zh2Hant = _zh2Hant\n",
    "    zh2Hans = _zh2Hans\n",
    "    UEMPTY = ''.decode('utf8')\n",
    "\n",
    "# states\n",
    "(START, END, FAIL, WAIT_TAIL) = list(range(4))\n",
    "# conditions\n",
    "(TAIL, ERROR, MATCHED_SWITCH, UNMATCHED_SWITCH, CONNECTOR) = list(range(5))\n",
    "\n",
    "MAPS = {}\n",
    "\n",
    "class Node(object):\n",
    "    def __init__(self, from_word, to_word=None, is_tail=True,\n",
    "            have_child=False):\n",
    "        self.from_word = from_word\n",
    "        if to_word is None:\n",
    "            self.to_word = from_word\n",
    "            self.data = (is_tail, have_child, from_word)\n",
    "            self.is_original = True\n",
    "        else:\n",
    "            self.to_word = to_word or from_word\n",
    "            self.data = (is_tail, have_child, to_word)\n",
    "            self.is_original = False\n",
    "        self.is_tail = is_tail\n",
    "        self.have_child = have_child\n",
    "\n",
    "    def is_original_long_word(self):\n",
    "        return self.is_original and len(self.from_word)>1\n",
    "\n",
    "    def is_follow(self, chars):\n",
    "        return chars != self.from_word[:-1]\n",
    "\n",
    "    def __str__(self):\n",
    "        return '<Node, %s, %s, %s, %s>' % (repr(self.from_word),\n",
    "                repr(self.to_word), self.is_tail, self.have_child)\n",
    "\n",
    "    __repr__ = __str__\n",
    "\n",
    "class ConvertMap(object):\n",
    "    def __init__(self, name, mapping=None):\n",
    "        self.name = name\n",
    "        self._map = {}\n",
    "        if mapping:\n",
    "            self.set_convert_map(mapping)\n",
    "\n",
    "    def set_convert_map(self, mapping):\n",
    "        convert_map = {}\n",
    "        have_child = {}\n",
    "        max_key_length = 0\n",
    "        for key in sorted(mapping.keys()):\n",
    "            if len(key)>1:\n",
    "                for i in range(1, len(key)):\n",
    "                    parent_key = key[:i]\n",
    "                    have_child[parent_key] = True\n",
    "            have_child[key] = False\n",
    "            max_key_length = max(max_key_length, len(key))\n",
    "        for key in sorted(have_child.keys()):\n",
    "            convert_map[key] = (key in mapping, have_child[key],\n",
    "                    mapping.get(key, UEMPTY))\n",
    "        self._map = convert_map\n",
    "        self.max_key_length = max_key_length\n",
    "\n",
    "    def __getitem__(self, k):\n",
    "        try:\n",
    "            is_tail, have_child, to_word  = self._map[k]\n",
    "            return Node(k, to_word, is_tail, have_child)\n",
    "        except:\n",
    "            return Node(k)\n",
    "\n",
    "    def __contains__(self, k):\n",
    "        return k in self._map\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self._map)\n",
    "\n",
    "class StatesMachineException(Exception): pass\n",
    "\n",
    "class StatesMachine(object):\n",
    "    def __init__(self):\n",
    "        self.state = START\n",
    "        self.final = UEMPTY\n",
    "        self.len = 0\n",
    "        self.pool = UEMPTY\n",
    "\n",
    "    def clone(self, pool):\n",
    "        new = deepcopy(self)\n",
    "        new.state = WAIT_TAIL\n",
    "        new.pool = pool\n",
    "        return new\n",
    "\n",
    "    def feed(self, char, map):\n",
    "        node = map[self.pool+char]\n",
    "\n",
    "        if node.have_child:\n",
    "            if node.is_tail:\n",
    "                if node.is_original:\n",
    "                    cond = UNMATCHED_SWITCH\n",
    "                else:\n",
    "                    cond = MATCHED_SWITCH\n",
    "            else:\n",
    "                cond = CONNECTOR\n",
    "        else:\n",
    "            if node.is_tail:\n",
    "                cond = TAIL\n",
    "            else:\n",
    "                cond = ERROR\n",
    "\n",
    "        new = None\n",
    "        if cond == ERROR:\n",
    "            self.state = FAIL\n",
    "        elif cond == TAIL:\n",
    "            if self.state == WAIT_TAIL and node.is_original_long_word():\n",
    "                self.state = FAIL\n",
    "            else:\n",
    "                self.final += node.to_word\n",
    "                self.len += 1\n",
    "                self.pool = UEMPTY\n",
    "                self.state = END\n",
    "        elif self.state == START or self.state == WAIT_TAIL:\n",
    "            if cond == MATCHED_SWITCH:\n",
    "                new = self.clone(node.from_word)\n",
    "                self.final += node.to_word\n",
    "                self.len += 1\n",
    "                self.state = END\n",
    "                self.pool = UEMPTY\n",
    "            elif cond == UNMATCHED_SWITCH or cond == CONNECTOR:\n",
    "                if self.state == START:\n",
    "                    new = self.clone(node.from_word)\n",
    "                    self.final += node.to_word\n",
    "                    self.len += 1\n",
    "                    self.state = END\n",
    "                else:\n",
    "                    if node.is_follow(self.pool):\n",
    "                        self.state = FAIL\n",
    "                    else:\n",
    "                        self.pool = node.from_word\n",
    "        elif self.state == END:\n",
    "            # END is a new START\n",
    "            self.state = START\n",
    "            new = self.feed(char, map)\n",
    "        elif self.state == FAIL:\n",
    "            raise StatesMachineException('Translate States Machine '\n",
    "                    'have error with input data %s' % node)\n",
    "        return new\n",
    "\n",
    "    def __len__(self):\n",
    "        return self.len + 1\n",
    "\n",
    "    def __str__(self):\n",
    "        return '<StatesMachine %s, pool: \"%s\", state: %s, final: %s>' % (\n",
    "                id(self), self.pool, self.state, self.final)\n",
    "    __repr__ = __str__\n",
    "\n",
    "class Converter(object):\n",
    "    def __init__(self, to_encoding):\n",
    "        self.to_encoding = to_encoding\n",
    "        self.map = MAPS[to_encoding]\n",
    "        self.start()\n",
    "\n",
    "    def feed(self, char):\n",
    "        branches = []\n",
    "        for fsm in self.machines:\n",
    "            new = fsm.feed(char, self.map)\n",
    "            if new:\n",
    "                branches.append(new)\n",
    "        if branches:\n",
    "            self.machines.extend(branches)\n",
    "        self.machines = [fsm for fsm in self.machines if fsm.state != FAIL]\n",
    "        all_ok = True\n",
    "        for fsm in self.machines:\n",
    "            if fsm.state != END:\n",
    "                all_ok = False\n",
    "        if all_ok:\n",
    "            self._clean()\n",
    "        return self.get_result()\n",
    "\n",
    "    def _clean(self):\n",
    "        if len(self.machines):\n",
    "            self.machines.sort(key=lambda x: len(x))\n",
    "            # self.machines.sort(cmp=lambda x,y: cmp(len(x), len(y)))\n",
    "            self.final += self.machines[0].final\n",
    "        self.machines = [StatesMachine()]\n",
    "\n",
    "    def start(self):\n",
    "        self.machines = [StatesMachine()]\n",
    "        self.final = UEMPTY\n",
    "\n",
    "    def end(self):\n",
    "        self.machines = [fsm for fsm in self.machines\n",
    "                if fsm.state == FAIL or fsm.state == END]\n",
    "        self._clean()\n",
    "\n",
    "    def convert(self, string):\n",
    "        self.start()\n",
    "        for char in string:\n",
    "            self.feed(char)\n",
    "        self.end()\n",
    "        return self.get_result()\n",
    "\n",
    "    def get_result(self):\n",
    "        return self.final\n",
    "\n",
    "\n",
    "def registery(name, mapping):\n",
    "    global MAPS\n",
    "    MAPS[name] = ConvertMap(name, mapping)\n",
    "\n",
    "registery('zh-hant', zh2Hant)\n",
    "registery('zh-hans', zh2Hans)\n",
    "del zh2Hant, zh2Hans\n",
    "\n",
    "\n",
    "def run():\n",
    "    import sys\n",
    "    from optparse import OptionParser\n",
    "    parser = OptionParser()\n",
    "    parser.add_option('-e', type='string', dest='encoding',\n",
    "            help='encoding')\n",
    "    parser.add_option('-f', type='string', dest='file_in',\n",
    "            help='input file (- for stdin)')\n",
    "    parser.add_option('-t', type='string', dest='file_out',\n",
    "            help='output file')\n",
    "    (options, args) = parser.parse_args()\n",
    "    if not options.encoding:\n",
    "        parser.error('encoding must be set')\n",
    "    if options.file_in:\n",
    "        if options.file_in == '-':\n",
    "            file_in = sys.stdin\n",
    "        else:\n",
    "            file_in = open(options.file_in)\n",
    "    else:\n",
    "        file_in = sys.stdin\n",
    "    if options.file_out:\n",
    "        if options.file_out == '-':\n",
    "            file_out = sys.stdout\n",
    "        else:\n",
    "            file_out = open(options.file_out, 'wb')\n",
    "    else:\n",
    "        file_out = sys.stdout\n",
    "\n",
    "    c = Converter(options.encoding)\n",
    "    for line in file_in:\n",
    "        # print >> file_out, c.convert(line.rstrip('\\n').decode(\n",
    "        file_out.write(c.convert(line.rstrip('\\n').decode(\n",
    "            'utf8')).encode('utf8'))\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    run()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
